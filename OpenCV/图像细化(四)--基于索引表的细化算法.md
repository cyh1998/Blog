## 前 言
本文介绍图像细化算法之 **基于索引表的细化算法**。

## 算法原理
设当前被处理的像素为p0，使用以下所示方式来表示当前像素的八邻域，背景像素值为0(黑色)，前景像素值为255(白色)，为了方便计算，在算法过程中将前景像素值当作1来计算。
```
p8  p1  p2
p7  p0  p3
p6  p5  p4
```
基于索引表的细化算法原理很简单：  
首先将八邻域的像素值(0,1)表示为8位二进制数，顺序为p7->p6->p5->p4->p3->p2->p1->p8。我们枚举出所有情况下，当前像素是否能够删除的值(能删除为1;反之为0)放入到表中，即一张256长度的索引表。  
由前人总结出的索引表如下：
```
unsigned char deletemark[256] = {
        0,0,0,0,0,0,0,1,    0,0,1,1,0,0,1,1,
        0,0,0,0,0,0,0,0,    0,0,1,1,1,0,1,1,
        0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
        0,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
        0,0,0,0,0,0,0,0,    0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,    0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
        1,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
        0,0,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
        0,0,0,0,0,0,0,0,    0,0,0,1,0,0,1,1,
        1,1,0,1,0,0,0,1,    0,0,0,0,0,0,0,0,
        1,1,0,1,0,0,0,1,    1,1,0,0,1,0,0,0,
        0,1,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
        0,0,0,0,0,0,0,0,    0,0,0,0,0,1,1,1,
        1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0,
        1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0
};//索引表
```
**步骤：**  
**1.** 遍历图像，找轮廓点，将其值值为5(这个值没有具体要求，这里只是为了方便还原细化后的前景为白色255，这里设为255/51)  
**2.** 查找所有轮廓，查找上文的索引表判断能否删除，能删除的话将其值置为0。

## 实 现
根据上文的算法步骤，实现的代码如下：
```
#include <iostream>
#include <vector>
#include <opencv2/opencv.hpp>

using namespace std;

void IndexTable_Thin(cv::Mat& src, cv::Mat& dst)
{
    if (src.type() != CV_8UC1) {
        cout << "只处理二值化图像，请先二值化图像" << endl;
        return;
    }

    src.copyTo(dst);
    int width = src.cols;
    int height = src.rows;
    int step = dst.step;
    bool ifEnd;
    int p1, p2, p3, p4, p5, p6, p7, p8; //八邻域
    uchar* img = dst.data;

    unsigned char deletemark[256] = {
            0,0,0,0,0,0,0,1,    0,0,1,1,0,0,1,1,
            0,0,0,0,0,0,0,0,    0,0,1,1,1,0,1,1,
            0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
            0,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
            0,0,0,0,0,0,0,0,    0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,    0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,    1,0,0,0,1,0,1,1,
            1,0,0,0,0,0,0,0,    1,0,1,1,1,0,1,1,
            0,0,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
            0,0,0,0,0,0,0,0,    0,0,0,1,0,0,1,1,
            1,1,0,1,0,0,0,1,    0,0,0,0,0,0,0,0,
            1,1,0,1,0,0,0,1,    1,1,0,0,1,0,0,0,
            0,1,1,1,0,0,1,1,    0,0,0,1,0,0,1,1,
            0,0,0,0,0,0,0,0,    0,0,0,0,0,1,1,1,
            1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0,
            1,1,1,1,0,0,1,1,    1,1,0,0,1,1,0,0
    };//索引表

    while (true) {
        ifEnd = false;
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                uchar* p = img + i * step + j;
                if (*p == 0) continue; //如果不是前景点,跳过
                 //判断八邻域像素点的值(要考虑边界的情况),若为前景点(白色255),则为1;反之为0
                p1 = p[(i == 0) ? 0 : -step] > 0 ? 1 : 0;
                p2 = p[(i == 0 || j == width - 1) ? 0 : -step + 1] > 0 ? 1 : 0;
                p3 = p[(j == width - 1) ? 0 : 1] > 0 ? 1 : 0;
                p4 = p[(i == height - 1 || j == width - 1) ? 0 : step + 1] > 0 ? 1 : 0;
                p5 = p[(i == height - 1) ? 0 : step] > 0 ? 1 : 0;
                p6 = p[(i == height - 1 || j == 0) ? 0 : step - 1] > 0 ? 1 : 0;
                p7 = p[(j == 0) ? 0 : -1] > 0 ? 1 : 0;
                p8 = p[(i == 0 || j == 0) ? 0 : -step - 1] > 0 ? 1 : 0;

                int sum = p8 & p1 & p2 & p3 & p4 & p5 & p6 & p7;
                if (sum == 0) { //这里判断边界的方式为八邻域不全为1，可以使用其他更优的方式判断
                    dst.at<uchar>(i, j) = 5; //若是边界点,将当前像素值设为5
                }
            }
        }
        
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                uchar* p = img + i * step + j;
                if (*p != 5) continue; //如果不是边界点,跳过
                p1 = p[(i == 0) ? 0 : -step] > 0 ? 1 : 0;
                p2 = p[(i == 0 || j == width - 1) ? 0 : -step + 1] > 0 ? 1 : 0;
                p3 = p[(j == width - 1) ? 0 : 1] > 0 ? 1 : 0;
                p4 = p[(i == height - 1 || j == width - 1) ? 0 : step + 1] > 0 ? 1 : 0;
                p5 = p[(i == height - 1) ? 0 : step] > 0 ? 1 : 0;
                p6 = p[(i == height - 1 || j == 0) ? 0 : step - 1] > 0 ? 1 : 0;
                p7 = p[(j == 0) ? 0 : -1] > 0 ? 1 : 0;
                p8 = p[(i == 0 || j == 0) ? 0 : -step - 1] > 0 ? 1 : 0;

                p1 = p1 << 1;
                p2 = p2 << 2;
                p3 = p3 << 3;
                p4 = p4 << 4;
                p5 = p5 << 5;
                p6 = p6 << 6;
                p7 = p7 << 7;

                int sum = p8 | p1 | p2 | p3 | p4 | p5 | p6 | p7;
                if (deletemark[sum] == 1) { //查询索引表,判断是否需要删除
                    dst.at<uchar>(i, j) = 0;
                    ifEnd = true;
                }

            }
        }
        if (!ifEnd) {
            dst = dst * 51; //将细化后的前景还原为白色
            break;
        }
    }
}

void main() {
    cv::Mat src = cv::imread("C:\\Users\\PC\\Desktop\\cv\\src.jpg");
    cv::cvtColor(src, src, cv::COLOR_BGR2GRAY); //将原图像转换为灰度图
    cv::threshold(src, src, 128, 255, cv::THRESH_BINARY); //二值化图像

    //图像细化
    cv::Mat dst;
    IndexTable_Thin(src, dst);
    //显示图像
    cv::imshow("src", src);
    cv::imshow("dst", dst);
    cv::waitKey(0);
}
```
## 效 果

![原图](https://upload-images.jianshu.io/upload_images/22192996-9444cc9208d74887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![基于索引表的细化算法](https://upload-images.jianshu.io/upload_images/22192996-f4e48485d469e07d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看到细化的效果不是特别好，会出现毛边，但基于索引表的细化算法速度很快。