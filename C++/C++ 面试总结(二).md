#### 1. C++中结构体和类的区别
C++中结构体和类基本相等
两者最主要的区别：
struct内部成员变量及成员函数默认的访问级别以及继承默认级别是public；
class的内部成员变量及成员函数默认的访问级别以及继承默认级别是private。

#### 2. C++11的新特性
1. 关键字及新语法：auto、nullptr、基于范围的 for 循环
2. STL容器：forward_list、unordered_map、unordered_set
3. 多线程：thread类、atomic
4. 其他：智能指针、lamda表达式

#### 3. 什么是类型安全，C++是否是类型安全的，为什么？
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。
C++相比于C，类型更加安全，但还不是类型安全的。因C++可以两个不同类型指针间做强制转换。

#### 4. explicit关键字的作用
explicit只能用于修饰只有一个参数的类构造函数，表明该构造函数不能发生隐式类型转换，只能以显示的方式进行类型转换。

#### 5. 什么是内存泄漏，如何避免
内存泄漏即内存空间使用完毕之后未回收；
避免的主要的方法：1.使用智能指针；2.善用 RAII

#### 6. 解释以下指针
```
int *p;  //int型指针
int **p;  //int型二级指针
int *p[10];  //int型指针数组
int (*p)[10];  //指向int型数组的指针
int (*p)(int);  //int型函数指针
int (*p[10])(int);  //int型函数指针数组
```

#### 7. 浮点数指针、字符指针和函数指针的内存大小
都是指针型变量，一样大

#### 8. 什么是智能指针，有哪些智能指针
智能指针为了避免申请的空间在函数结束时忘记释放，造成内存泄漏。所以智能指针的作用就是在函数结束时自动释放内存空间。
C++里面的四个智能指针: auto_ptr, unique_ptr,shared_ptr, weak_ptr 其中后三个是C++11支持，并且第一个已经被C++11弃用。
学习参考：[https://www.cnblogs.com/WindSun/p/11444429.html](https://www.cnblogs.com/WindSun/p/11444429.html)

#### 9. size_t在不同操作系统中的大小
32位系统 4字节
64位系统 8字节

#### 10. 为什么要将析构函数设为虚函数
在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生

#### 11. 在什么情况下把析构函数定义为私有的
将析构函数声明为私有时，就意味着析构函数只能在类域中被调用，无法被外界（包括自己的对象）调用。即禁止在栈内存空间内创建此类型的对象。要创建对象，只能用 new 在堆上进行；禁止用户在程序中使用 delete 删除此类型对象。对象的删除只能在类内实现，也就是说只有类的实现者才有可能实现对对象的 delete，用户不能随便删除对象。
简单来讲，即保证一个对象只能在堆上生成。

#### 12. 解释编译时多态和运行时多态
编译时多态发生在程序编译时，以不同的模板参数具现化导致调用不同的函数。在C++中主要体现为模板。
运行时多态发生在程序运行时，动态绑定所调用的函数，动态地找到了调用函数的入口地址，从而确定到底调用哪个函数。在C++中主要体现为虚函数和继承。

#### 13. map和unordered_map的区别
头文件不同，分别是 `#include<map>` 和 `#include<unordered_map>`；
map是有序的，而unordered_map是无序的

#### 14. 线程同步的方法
临界区、互斥锁、信号量、事件

#### 15. 线程如何使用类成员函数
```
#include <iostream>
#include <thread>

using namespace std;

class A {
public:
    void foo(int n) { 
        cout << n << endl; 
    }
};

int main()
{
    A a;
    std::thread t1(&A::foo, ref(a), 100);
    t1.join();
    return 0;
}
```
