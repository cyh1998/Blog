#### 1. NULL 和 nullptr 的区别
简单一点讲：在C++中，`NULL`实际上就是0；而`nullptr`代指空指针，以解决0表示空指针在函数重载时出现的问题
#### 2. inline 关键字
`inline`表示内联函数，在函数定义时使用。为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题
#### 3. 构造函数的写法
在类的定义中经常会看到这样的写法：
```
class demo{
    public:
        demo(int var) : m_Var(var){}
}
```
构造函数冒号语法后面的内容相当于初始化，即：`int m_Var = var`
#### 4. 函数的形参前面加&
形参前加&表示引用，即可以在函数内部更改传入的变量本身
#### 5. 指针和引用的区别
指针是一个变量，变量的内容是所指内存的地址；而引用则是某块内存的别名。
区别：
- 指针是一个实体，而引用仅是个别名；
- `sizeof指针` 得到的是指针本身的大小，而 `sizeof引用` 得到的则是被引用对象的大小；
- 指针可以被初始化为 `nullptr` ，而引用不能为空且在定义的时候必须初始化；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；
- 指针和引用使用`++`运算符的意义不一样；
- 指针可以有多级，但是引用只能是一级；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查）

参考：[https://blog.csdn.net/weikangc/article/details/49762929](https://blog.csdn.net/weikangc/article/details/49762929)
#### 6. 指针和引用作为函数参数进行传递时的区别
指针作为函数参数进行传递时，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址；  
引用作为函数参数进行传递时，实质上传递的是实参本身，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。
#### 7. const关键字
用 `const` 修饰一个变量时，该变量将无法被改变，所以在定义该const变量时，必须先初始化；  
对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  
在一个函数声明中，const可以来修饰形参，表明在函数内部该参数的值不可改变；  
对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；  
对于类的成员函数，有时候必须指定其返回值为const类型。因为左值会把返回值作为变量，修改其返回值，const声明禁止这种修改。  
参考：[https://blog.csdn.net/ypshowm/article/details/89030156](https://blog.csdn.net/ypshowm/article/details/89030156)
***
2020.4.14更新
#### 8. 野指针以及其避免
野指针，就是指向不可用内存区域的指针。野指针不是NULL指针，是指向“垃圾”内存的指针。  
如何避免？
```
delete tmp;
tmp = nullptr;
```
在删除完指针之后，一定要将其变成空指针！
***
2020.4.29更新
#### 9. enum关键字
enum为枚举类型，可以自定义若干枚举常量，语法 `enum <类型名> {<枚举常量表>};`
```
enum color {Red,Black,Blue}
//Red = 0，Black = 1，Blue = 2
```
枚举常量代表该枚举类型的变量可能取的值，并为其指定一个数值，默认情况从0开始，依次加一。若定义时为变量赋值，则后面的变量依次按照赋值的数值加一
```
enum color {Red,Black=2,Blue}
//Red = 0，Black = 2，Blue = 3
```
#### 10.#define定义函数
`#define`可以直接定义函数并接受参数，如：
```
#define fun(x) (x * 2)
```
因为没有返回类型，所以#define并不安全。而且#define只是简单的替换，在使用时会出现运算先后顺序的问题。




















